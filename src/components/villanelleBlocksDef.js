import Blockly from 'blockly';


export initializeBlocks(){
Blockly.Blocks['villanellprog'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("Initialization:");
    this.appendStatementInput("initialization")
        .setCheck("setVariable");
    this.appendDummyInput()
        .appendField("User Interaction:");
    this.appendStatementInput("userInteraction")
        .setCheck(["description", "userAction", "condition", "node"]);
    this.setColour(120);
 this.setTooltip("");
 this.setHelpUrl("");
 
 //NOTE: The following code will not be automatically generated by blockly's factory
 //therefore, make sure to be careful not to override it
	this.setMutator(new Blockly.Mutator(['main_vill', 'new_agent']));
  },
  agentCount_: 0,

  /**
   * Don't automatically add STATEMENT_PREFIX and STATEMENT_SUFFIX to generated
   * code.  These will be handled manually in this block's generators.
   */
  suppressPrefixSuffix: true,

  /**
   * Create XML to represent the number of else-if and else inputs.
   * @return {Element} XML storage element.
   * @this {Blockly.Block}
   */
  mutationToDom: function() {
    if (!this.agentCount_) {
      return null;
    }
    var container = Blockly.utils.xml.createElement('mutation');
    if (this.agentCount_) {
      container.setAttribute('agents', this.agentCount_);
    }
    
    return container;
  },
  /**
   * Parse XML to restore the else-if and else inputs.
   * @param {!Element} xmlElement XML storage element.
   * @this {Blockly.Block}
   */
  domToMutation: function(xmlElement) {
    this.agentCount_ = parseInt(xmlElement.getAttribute('agents'), 10) || 0;
    this.rebuildShape_();
  },
  /**
   * Populate the mutator's dialog with this block's components.
   * @param {!Blockly.Workspace} workspace Mutator's workspace.
   * @return {!Blockly.Block} Root block in mutator.
   * @this {Blockly.Block}
   */
  decompose: function(workspace) {
    var containerBlock = workspace.newBlock('main_vill');
    containerBlock.initSvg();
    var connection = containerBlock.nextConnection;
    for (var i = 1; i <= this.agentCount_; i++) {
      var agentBlock = workspace.newBlock('new_agent');
      agentBlock.initSvg();
      connection.connect(agentBlock.previousConnection);
      connection = agentBlock.nextConnection;
    }
	
    return containerBlock;
  },
  /**
   * Reconfigure this block based on the mutator dialog's components.
   * @param {!Blockly.Block} containerBlock Root block in mutator.
   * @this {Blockly.Block}
   */
  compose: function(containerBlock) {
    var clauseBlock = containerBlock.nextConnection.targetBlock();
    // Count number of inputs.
    this.agentCount_ = 0;

    var valueConnections = [null];
    var statementConnections = [null];
    var elseStatementConnection = null;
    while (clauseBlock) {
      switch (clauseBlock.type) {
        case 'new_agent':
          this.agentCount_++;
          valueConnections.push(clauseBlock.valueConnection_);
          statementConnections.push(clauseBlock.statementConnection_);
          break;
        default:
          throw TypeError('Unknown block type: ' + clauseBlock.type);
      }
      clauseBlock = clauseBlock.nextConnection &&
          clauseBlock.nextConnection.targetBlock();
    }
    this.updateShape_();
    // Reconnect any child blocks.
    this.reconnectChildBlocks_(valueConnections, statementConnections,
        elseStatementConnection);
  },
  /**
   * Store pointers to any connected child blocks.
   * @param {!Blockly.Block} containerBlock Root block in mutator.
   * @this {Blockly.Block}
   */
  saveConnections: function(containerBlock) {
    var clauseBlock = containerBlock.nextConnection.targetBlock();
    var i = 1;
    while (clauseBlock) {
      switch (clauseBlock.type) {
        case 'new_agent':
          var inputIf = this.getInput('AGENT' + i);
          clauseBlock.valueConnection_ =
              inputIf && inputIf.connection.targetConnection;
          i++;
          break;
        default:
          throw TypeError('Unknown block type: ' + clauseBlock.type);
      }
      clauseBlock = clauseBlock.nextConnection &&
          clauseBlock.nextConnection.targetBlock();
    }
  },
  /**
   * Reconstructs the block with all child blocks attached.
   * @this {Blockly.Block}
   */
  rebuildShape_: function() {
    var valueConnections = [null];
    var statementConnections = [null];

    var i = 1;
    while (this.getInput('AGENT' + i)) {
      var inputIf = this.getInput('AGENT' + i);
      statementConnections.push(inputIf.connection.targetConnection);
      i++;
    }
    this.updateShape_();
    this.reconnectChildBlocks_(valueConnections, statementConnections);
  },
  /**
   * Modify this block to have the correct number of inputs.
   * @this {Blockly.Block}
   * @private
   */
  updateShape_: function() {
    // Delete everything.

    var i = 1;
    while (this.getInput('AGENT' + i)) {
      this.removeInput('AGENT' + i);
      i++;
    }
    // Rebuild block.
    for (i = 1; i <= this.agentCount_; i++) {
      this.appendStatementInput('AGENT' + i)
          .setCheck(['condition', 'node'])
          .appendField('Agent')
		  .appendField(new Blockly.FieldTextInput("<agent_name>"), "agentName" + i);
    }

  },
  /**
   * Reconnects child blocks.
   * @param {!Array.<?Blockly.RenderedConnection>} valueConnections List of
   * value connections for 'if' input.
   * @param {!Array.<?Blockly.RenderedConnection>} statementConnections List of
   * statement connections for 'do' input.
   * @param {?Blockly.RenderedConnection} elseStatementConnection Statement
   * connection for else input.
   * @this {Blockly.Block}
   */
  reconnectChildBlocks_: function(valueConnections, statementConnections) {
    for (var i = 1; i <= this.agentCount_; i++) {
      Blockly.Mutator.reconnect(valueConnections[i], this, 'AGENT' + i);
    }
  }
};


Blockly.Blocks['setvariable'] = {
  init: function() {
    this.appendValueInput("variableValue")
        .setCheck(["Boolean", "Number", "String"])
        .appendField("Set variable")
        .appendField(new Blockly.FieldTextInput("<var_name>"), "variableName")
        .appendField("to");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(65);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};

Blockly.Blocks['description'] = {
  init: function() {
    this.appendValueInput("NAME")
        .setCheck("String")
        .appendField("Description");
    this.setPreviousStatement(true, ["description", "userAction", "condition", "node"]);
    this.setNextStatement(true, ["description", "userAction", "condition", "node"]);
    this.setColour(20);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};

Blockly.Blocks['useraction'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("User Action");
    this.appendValueInput("actionText")
        .setCheck("String")
        .appendField("Action Text:");
    this.appendStatementInput("effects")
        .setCheck("setVariable")
        .appendField("Effects:");
    this.setPreviousStatement(true, ["description", "userAction", "condition", "node"]);
    this.setNextStatement(true, ["description", "userAction", "condition", "node"]);
    this.setColour(20);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};

Blockly.Blocks['node'] = {
  init: function() {
    this.appendDummyInput()
        .appendField(new Blockly.FieldDropdown([["Selector","selector"], ["Sequence","sequence"]]), "type");
    this.appendStatementInput("body")
        .setCheck(["description", "userAction", "effectText", "condition", "node", "effects"]);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};

Blockly.Blocks['agent'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("Agent: ")
        .appendField(new Blockly.FieldTextInput("<agent_name>"), "name");
    this.appendStatementInput("body")
        .setCheck(["condition", "node"]);
    this.setPreviousStatement(true, "agent");
    this.setNextStatement(true, "agent");
    this.setColour(230);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};

Blockly.Blocks['effecttext'] = {
  init: function() {
    this.appendValueInput("text")
        .setCheck("String")
        .appendField("Effect Text:");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};

Blockly.Blocks['effects'] = {
  init: function() {
    this.appendStatementInput("substatementList")
        .setCheck("setVariable")
        .appendField("Set Variables:");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};

Blockly.Blocks['getvariable'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("Variable")
        .appendField(new Blockly.FieldTextInput("<var_name>"), "varName");
    this.setOutput(true, null);
    this.setColour(230);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};

Blockly.Blocks['condition'] = {
  init: function() {
    this.appendValueInput("antecedent")
        .setCheck(null)
        .appendField("if");
    this.appendStatementInput("consequent")
        .setCheck(null)
        .appendField("do");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};




/*DO NOT OVERWRITE THIS
//Creating mutator for Villanelle Main Block
//Probably shouldn't add this to the logic pack, but at the moment not worried
VILLANELLE_MAIN_MUTATOR = {
  
  }
};

Blockly.Extensions.registerMutator('vill_main_mutator', VILLANELLE_MAIN_MUTATOR, null, ['agent']);*/
/*END DO NOT OVERWRITE THIS*/
//For Use in mutator:

Blockly.Blocks['main_vill'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("Initialization");
    this.appendDummyInput()
        .appendField("User Interaction");
    this.setNextStatement(true, null);
    this.setColour(230);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};
Blockly.Blocks['new_agent'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("Agent");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
 this.setTooltip("");
 this.setHelpUrl("");
  }
};
}